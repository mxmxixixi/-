第二十道:[744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)https://leetcode-cn.com/problems/valid-palindrome-ii/)

给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。

在比较时，字母是依序循环出现的。举个例子：

如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'


示例：

输入:
letters = ["c", "f", "j"]
target = "a"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "c"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "d"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "g"
输出: "j"

输入:
letters = ["c", "f", "j"]
target = "j"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "k"
输出: "c"


提示：

letters长度范围在[2, 10000]区间内。
letters 仅由小写字母组成，最少包含两个不同的字母。
目标字母target 是一个小写字母。

<font color="red">第一次解题思路:</font>

- 已经有顺序的数组中找到比目标字母大的最小字母，
- 首先先找到比目标字母大的字母，所以可以使用二分法
- 首先判断排序字符是升序还是降序，通过升序与降序左右指针的移动不同
- 时间复杂度o(logn),空间复杂度o(1)

```javascript
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
    let sort =''
    if(letters[0]>letters[1]){
        sort = 'desc'
    }else{
        sort = 'asc'
    }
    let left=0,right=letters.length-1,ans=''
    while(left<=right){
        let avg =  Math.floor(left+(right-left)/2)
        if(target<letters[avg]){
            ans=letters[avg]
            if(sort === 'asc'){
                right=avg-1
            }else{
                left=avg+1
            }
            
        }else{
            if(sort === 'asc'){
                left=avg+1
            }else{
                right=avg-1
            }
            
        }
    }
    return ans ? ans:letters[0]
};
```

<font color="red">第二次解题思路[看题解后]:</font>

- 这个题还有一个规律就是当给的目标字段不在letters的字符所包含的范围内，那就取第一个值，这种运算可以用模
- 时间复杂度o(logn),空间复杂度o(1)

```javascript
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
    let sort =''
    if(letters[0]>letters[1]){
        sort = 'desc'
    }else{
        sort = 'asc'
    }
    let left=0,right=letters.length-1
    while(left<=right){
        let avg =  Math.floor(left+(right-left)/2)
        if(target<letters[avg]){
            if(sort === 'asc'){
                right=avg-1
            }else{
                left=avg+1
            }
            
        }else{
            if(sort === 'asc'){
                left=avg+1
            }else{
                right=avg-1
            }
            
        }
    }
    return letters[left%letters.length]
};
```

<font color="red">总结考点:</font>

- 二分法
- 双指针循环数组
- 单个字符可直接比较，按照ASCII值，不需要使用charcodeAt()

<font size="2">备注：第一次新建:2020-12-02</font>

